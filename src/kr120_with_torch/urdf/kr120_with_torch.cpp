/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2017-03-27 10:41:58.419945
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59,x60,x61,x62,x63,x64;
x0=IKcos(j[4]);
x1=IKcos(j[0]);
x2=IKsin(j[1]);
x3=IKsin(j[2]);
x4=(x2*x3);
x5=((1.0)*x4);
x6=(x1*x5);
x7=IKcos(j[1]);
x8=IKcos(j[2]);
x9=(x7*x8);
x10=((1.0)*x9);
x11=(x0*(((((-1.0)*(1.0)*x1*x10))+x6)));
x12=IKsin(j[5]);
x13=IKsin(j[0]);
x14=IKcos(j[3]);
x15=(x13*x14);
x16=IKsin(j[3]);
x17=(x2*x8);
x18=((1.0)*x17);
x19=(x3*x7);
x20=((1.0)*x19);
x21=(x1*(((((-1.0)*(1.0)*x20))+(((-1.0)*(1.0)*x18)))));
x22=(x16*x21);
x23=(x15+x22);
x24=(x12*x23);
x25=IKsin(j[4]);
x26=(x13*x16);
x27=(x14*x21);
x28=((((-1.0)*(1.0)*x27))+(((1.0)*x26)));
x29=(x25*x28);
x30=IKcos(j[5]);
x31=(((x1*x9))+(((-1.0)*(1.0)*x6)));
x32=(x25*x31);
x33=(x0*x28);
x34=(x30*((x33+x32)));
x35=((1.15)*x7);
x36=((0.041)*x1);
x37=((0.541)*x4);
x38=((0.541)*x9);
x39=(x13*x5);
x40=((-1.0)*(((1.0)*x10*x13)));
x41=(x0*((x39+x40)));
x42=(x1*x14);
x43=((1.0)*x42);
x44=(x13*(((((-1.0)*(1.0)*x20))+(((-1.0)*(1.0)*x18)))));
x45=(x16*x44);
x46=(x12*((x45+(((-1.0)*(1.0)*x43)))));
x47=(x1*x16);
x48=(x14*x44);
x49=((((-1.0)*(1.0)*x48))+(((-1.0)*(1.0)*x47)));
x50=(x25*x49);
x51=(x25*(((((-1.0)*(1.0)*x39))+((x13*x9)))));
x52=(x0*x49);
x53=(x51+x52);
x54=(x30*x53);
x55=((0.041)*x13);
x56=((((-1.0)*(1.0)*x20))+(((-1.0)*(1.0)*x18)));
x57=(x0*x56);
x58=((((-1.0)*(1.0)*x10))+x4);
x59=(x14*x25*x58);
x60=(x12*x16*((x10+(((-1.0)*(1.0)*x5)))));
x61=(x25*((x19+x17)));
x62=(x0*x14*x58);
x63=(x61+x62);
x64=(x30*x63);
eerot[0]=((((-1.0)*(0.707201775043323)*x24))+(((-1.0)*(0.707201775043323)*x34))+(((0.707011774566431)*x11))+(((0.707011774566431)*x29)));
eerot[1]=(((x12*(((((-1.0)*(1.0)*x32))+(((-1.0)*(1.0)*x33))))))+((x23*x30)));
eerot[2]=((((-1.0)*(0.707201775043323)*x11))+(((-1.0)*(0.707201775043323)*x29))+(((-1.0)*(0.707011774566431)*x34))+(((-1.0)*(0.707011774566431)*x24)));
IkReal x65=((1.0)*x36);
eetrans[0]=(x31+((x25*(((((0.541)*x27))+(((-1.0)*(0.541)*x26))))))+(((0.35)*x1))+((x1*x35))+(((-1.0)*x19*x65))+((x30*(((((0.034)*x32))+(((0.034)*x33))))))+((x12*(((((0.034)*x22))+(((0.034)*x15))))))+((x0*(((((-1.0)*(1.0)*x1*x37))+((x1*x38))))))+(((-1.0)*x17*x65)));
eerot[3]=((((0.707201775043323)*x46))+(((-1.0)*(0.707011774566431)*x50))+(((0.707201775043323)*x54))+(((-1.0)*(0.707011774566431)*x41)));
eerot[4]=(((x12*x53))+((x30*(((((-1.0)*(1.0)*x45))+x43)))));
eerot[5]=((((0.707201775043323)*x41))+(((0.707011774566431)*x46))+(((0.707011774566431)*x54))+(((0.707201775043323)*x50)));
IkReal x66=((1.0)*x13);
eetrans[1]=((((-1.0)*(0.35)*x13))+((x19*x55))+((x0*(((((-1.0)*x38*x66))+((x13*x37))))))+(((-1.0)*x35*x66))+((x13*x4))+((x12*(((((0.034)*x42))+(((-1.0)*(0.034)*x45))))))+((x30*(((((-1.0)*(0.034)*x52))+(((-1.0)*(0.034)*x51))))))+((x25*(((((-1.0)*(0.541)*x48))+(((-1.0)*(0.541)*x47))))))+((x17*x55))+x40);
eerot[6]=((((-1.0)*(0.707011774566431)*x57))+(((0.707201775043323)*x64))+(((0.707201775043323)*x60))+(((-1.0)*(0.707011774566431)*x59)));
eerot[7]=(((x12*x63))+((x16*x30*x58)));
eerot[8]=((((0.707201775043323)*x59))+(((0.707011774566431)*x64))+(((0.707011774566431)*x60))+(((0.707201775043323)*x57)));
eetrans[2]=((0.675)+((x12*x16*(((((0.034)*x4))+(((-1.0)*(0.034)*x9))))))+(((-1.0)*(1.15)*x2))+((x14*x25*((x37+(((-1.0)*(1.0)*x38))))))+(((-1.0)*(0.041)*x9))+(((0.041)*x4))+((x0*(((((-1.0)*(0.541)*x19))+(((-1.0)*(0.541)*x17))))))+((x30*(((((-1.0)*(0.034)*x61))+(((-1.0)*(0.034)*x62))))))+x56);
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 6; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((((-1.0)*(0.707201775043323)*r00))+(((-1.0)*(0.707011774566431)*r02)));
new_r01=r01;
new_r02=((((0.707011774566431)*r00))+(((-1.0)*(0.707201775043323)*r02)));
new_px=((((0.406538230391912)*r00))+px+(((-1.0)*(0.358557759963179)*r02)));
new_r10=((((0.707011774566431)*r12))+(((0.707201775043323)*r10)));
new_r11=((-1.0)*(((1.0)*r11)));
new_r12=((((0.707201775043323)*r12))+(((-1.0)*(0.707011774566431)*r10)));
new_py=((((-1.0)*(0.406538230391912)*r10))+(((0.358557759963179)*r12))+(((-1.0)*(1.0)*py)));
new_r20=((((0.707011774566431)*r22))+(((0.707201775043323)*r20)));
new_r21=((-1.0)*(((1.0)*r21)));
new_r22=((((0.707201775043323)*r22))+(((-1.0)*(0.707011774566431)*r20)));
new_pz=((0.675)+(((-1.0)*(1.0)*pz))+(((0.358557759963179)*r22))+(((-1.0)*(0.406538230391912)*r20)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x67=((1.0)*py);
IkReal x68=((1.0)*pz);
IkReal x69=((1.0)*px);
pp=((pz*pz)+(py*py)+(px*px));
npx=(((pz*r20))+((py*r10))+((px*r00)));
npy=(((pz*r21))+((py*r11))+((px*r01)));
npz=(((px*r02))+((pz*r22))+((py*r12)));
rxp0_0=((((-1.0)*r20*x67))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x68)));
rxp0_2=(((py*r00))+(((-1.0)*r10*x69)));
rxp1_0=((((-1.0)*r21*x67))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x68)));
rxp1_2=((((-1.0)*r11*x69))+((py*r01)));
rxp2_0=((((-1.0)*r22*x67))+((pz*r12)));
rxp2_1=((((-1.0)*r02*x68))+((px*r22)));
rxp2_2=(((py*r02))+(((-1.0)*r12*x69)));
{
IkReal j0eval[1];
j0eval[0]=((IKabs(py))+(IKabs(px)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1, j2]

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x71 = IKatan2WithCheck(IkReal(py),((-1.0)*(((1.0)*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x71.valid){
continue;
}
IkReal x70=((-1.0)*(x71.value));
j0array[0]=x70;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+x70);
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
if( (((0.956449050821836)+(((0.304092343793349)*cj0*px))+(((-1.0)*(0.434417633990499)*pp))+(((0.304092343793349)*py*sj0)))) < -1-IKFAST_SINCOS_THRESH || (((0.956449050821836)+(((0.304092343793349)*cj0*px))+(((-1.0)*(0.434417633990499)*pp))+(((0.304092343793349)*py*sj0)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x72=IKasin(((0.956449050821836)+(((0.304092343793349)*cj0*px))+(((-1.0)*(0.434417633990499)*pp))+(((0.304092343793349)*py*sj0))));
j2array[0]=((-1.61177337627168)+(((-1.0)*x72)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((1.52981927731811)+x72);
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j1eval[3];
IkReal x73=(cj2*pz);
IkReal x74=(pz*sj2);
IkReal x75=(cj0*cj2*px);
IkReal x76=(cj0*px);
IkReal x77=(sj2*x76);
IkReal x78=(cj2*py*sj0);
IkReal x79=(py*sj0);
IkReal x80=(sj2*x79);
IkReal x81=(cj2*sj2);
IkReal x82=cj2*cj2;
j1eval[0]=((((2.85714285714286)*x78))+(((-1.0)*(1.0)*cj2))+(((69.6864111498258)*x73))+(((-1.0)*(24.390243902439)*sj2))+(((80.1393728222996)*pz))+(((2.85714285714286)*x75))+(((69.6864111498258)*x80))+(((69.6864111498258)*x77))+(((-2.85714285714286)*x74)));
j1eval[1]=IKsign(((((-1.0)*(0.01435)*cj2))+x80+(((-1.0)*(0.35)*sj2))+(((0.041)*x75))+(((-0.041)*x74))+x73+x77+(((0.041)*x78))+(((1.15)*pz))));
j1eval[2]=((IKabs(((-0.041)+((pz*x79))+(((0.082)*x82))+(((-1.0)*(0.35)*pz))+(((0.04715)*cj2))+(((0.998319)*x81))+((pz*x76))+(((1.15)*sj2)))))+(IKabs(((-1.0)+(((-0.082)*x81))+(pz*pz)+(((0.998319)*x82))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
j1eval[0]=((-24.6466702014846)+(((-1.0)*(24.390243902439)*cj2))+sj2);
j1eval[1]=IKsign(((-2.324181)+(((-1.0)*(2.3)*cj2))+(((0.0943)*sj2))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x83=(cj0*px);
IkReal x84=(cj2*pz);
IkReal x85=(py*sj0);
IkReal x86=(pz*sj2);
IkReal x87=(cj0*cj2*px);
IkReal x88=(cj0*px*sj2);
IkReal x89=(cj2*py*sj0);
IkReal x90=(py*sj0*sj2);
j1eval[0]=((28.0487804878049)+(((2.85714285714286)*x84))+(((-1.0)*(1.0)*sj2))+(((69.6864111498258)*x86))+(((-80.1393728222996)*x83))+(((24.390243902439)*cj2))+(((2.85714285714286)*x88))+(((-69.6864111498258)*x89))+(((-80.1393728222996)*x85))+(((-69.6864111498258)*x87))+(((2.85714285714286)*x90)));
j1eval[1]=IKsign(((0.4025)+(((0.35)*cj2))+(((0.041)*x88))+(((-1.0)*x89))+(((0.041)*x90))+(((-1.0)*(0.01435)*sj2))+(((-1.0)*x87))+x86+(((-1.15)*x83))+(((0.041)*x84))+(((-1.15)*x85))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x91=(cj0*px);
IkReal x92=(py*sj0);
IkReal x93=((1.0)*cj0*px);
IkReal x94=((0.041)*sj2);
IkReal x95=((1.0)*py*sj0);
IkReal x96=(cj2*sj2);
IkReal x97=cj2*cj2;
CheckValue<IkReal> x98 = IKatan2WithCheck(IkReal(((-0.041)+(((0.082)*x97))+(((-1.0)*pz*x93))+(((0.04715)*cj2))+(((0.998319)*x96))+(((-1.0)*pz*x95))+(((0.35)*pz))+(((1.15)*sj2)))),((-1.324181)+(((-1.0)*(2.3)*cj2))+(pz*pz)+(((0.082)*x96))+(((-0.998319)*x97))+(((0.0943)*sj2))),IKFAST_ATAN2_MAGTHRESH);
if(!x98.valid){
continue;
}
CheckValue<IkReal> x99=IKPowWithIntegerCheck(IKsign(((0.4025)+(((0.35)*cj2))+(((-1.0)*cj2*x93))+(((-1.0)*cj2*x95))+(((-1.0)*(0.01435)*sj2))+(((-1.15)*x92))+((pz*sj2))+(((-1.15)*x91))+((x91*x94))+(((0.041)*cj2*pz))+((x92*x94)))),-1);
if(!x99.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x98.value)+(((1.5707963267949)*(x99.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x100=((0.041)*cj2);
IkReal x101=IKsin(j1);
IkReal x102=IKcos(j1);
IkReal x103=((1.0)*pz);
IkReal x104=(cj0*px);
IkReal x105=(py*sj0);
IkReal x106=((0.041)*sj2);
IkReal x107=((1.0)*x104);
IkReal x108=((1.0)*x105);
IkReal x109=((2.3)*x102);
evalcond[0]=(x100+(((-0.35)*x101))+sj2+((x101*x105))+(((-1.0)*x102*x103))+((x101*x104)));
evalcond[1]=((1.15)+(((-1.0)*x101*x103))+(((0.35)*x102))+(((-1.0)*x106))+cj2+(((-1.0)*x102*x107))+(((-1.0)*x102*x108)));
evalcond[2]=(((cj2*x101))+((x100*x102))+((sj2*x102))+(((-1.0)*x103))+(((-1.0)*x101*x106))+(((1.15)*x101)));
evalcond[3]=((-0.443319)+((x104*x109))+(((0.7)*x104))+(((-0.805)*x102))+(((2.3)*pz*x101))+(((0.7)*x105))+((x105*x109))+(((-1.0)*(1.0)*pp)));
evalcond[4]=((0.35)+(((-1.0)*x102*x106))+(((1.15)*x102))+(((-1.0)*x100*x101))+(((-1.0)*x108))+(((-1.0)*x107))+(((-1.0)*sj2*x101))+((cj2*x102)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x491=(cj2*pz);
IkReal x492=(pz*sj2);
IkReal x493=(cj0*px);
IkReal x494=(sj2*x493);
IkReal x495=(py*sj0);
IkReal x496=(sj2*x495);
IkReal x497=(cj0*cj2*px);
IkReal x498=(cj2*py*sj0);
CheckValue<IkReal> x499 = IKatan2WithCheck(IkReal(((((0.041)*x492))+(((0.041)*x498))+(((-1.0)*(0.01435)*cj2))+(((-1.0)*(0.35)*sj2))+(((0.041)*x497))+(((-1.0)*x491))+(((-1.0)*(1.15)*pz))+x494+x496)),((0.4025)+(((0.35)*cj2))+(((-1.15)*x495))+(((-0.041)*x491))+(((-1.15)*x493))+(((0.041)*x494))+(((-1.0)*x498))+(((-1.0)*x492))+(((-1.0)*(0.01435)*sj2))+(((0.041)*x496))+(((-1.0)*x497))),IKFAST_ATAN2_MAGTHRESH);
if(!x499.valid){
continue;
}
CheckValue<IkReal> x500=IKPowWithIntegerCheck(IKsign(((-2.324181)+(((-1.0)*(2.3)*cj2))+(((0.0943)*sj2)))),-1);
if(!x500.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x499.value)+(((1.5707963267949)*(x500.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x501=((0.041)*cj2);
IkReal x502=IKsin(j1);
IkReal x503=IKcos(j1);
IkReal x504=((1.0)*pz);
IkReal x505=(cj0*px);
IkReal x506=(py*sj0);
IkReal x507=((0.041)*sj2);
IkReal x508=((1.0)*x505);
IkReal x509=((1.0)*x506);
IkReal x510=((2.3)*x503);
evalcond[0]=((((-0.35)*x502))+x501+sj2+((x502*x506))+((x502*x505))+(((-1.0)*x503*x504)));
evalcond[1]=((1.15)+(((-1.0)*x502*x504))+(((-1.0)*x507))+(((-1.0)*x503*x509))+(((0.35)*x503))+cj2+(((-1.0)*x503*x508)));
evalcond[2]=(((sj2*x503))+((x501*x503))+((cj2*x502))+(((-1.0)*x504))+(((1.15)*x502))+(((-1.0)*x502*x507)));
evalcond[3]=((-0.443319)+((x506*x510))+(((-0.805)*x503))+(((0.7)*x505))+(((2.3)*pz*x502))+(((-1.0)*(1.0)*pp))+(((0.7)*x506))+((x505*x510)));
evalcond[4]=((0.35)+(((-1.0)*sj2*x502))+((cj2*x503))+(((-1.0)*x501*x502))+(((1.15)*x503))+(((-1.0)*x508))+(((-1.0)*x503*x507))+(((-1.0)*x509)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x511=(cj0*px);
IkReal x512=(py*sj0);
IkReal x513=((0.041)*cj2);
IkReal x514=(cj2*sj2);
IkReal x515=cj2*cj2;
CheckValue<IkReal> x516=IKPowWithIntegerCheck(IKsign((((cj2*pz))+((x511*x513))+(((-1.0)*(0.01435)*cj2))+(((-1.0)*(0.35)*sj2))+((sj2*x511))+((sj2*x512))+(((-1.0)*(0.041)*pz*sj2))+(((1.15)*pz))+((x512*x513)))),-1);
if(!x516.valid){
continue;
}
CheckValue<IkReal> x517 = IKatan2WithCheck(IkReal(((-1.0)+(pz*pz)+(((0.998319)*x515))+(((-0.082)*x514)))),((-0.041)+(((0.082)*x515))+(((-1.0)*(0.35)*pz))+(((0.04715)*cj2))+((pz*x512))+(((0.998319)*x514))+((pz*x511))+(((1.15)*sj2))),IKFAST_ATAN2_MAGTHRESH);
if(!x517.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x516.value)))+(x517.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x518=((0.041)*cj2);
IkReal x519=IKsin(j1);
IkReal x520=IKcos(j1);
IkReal x521=((1.0)*pz);
IkReal x522=(cj0*px);
IkReal x523=(py*sj0);
IkReal x524=((0.041)*sj2);
IkReal x525=((1.0)*x522);
IkReal x526=((1.0)*x523);
IkReal x527=((2.3)*x520);
evalcond[0]=((((-1.0)*x520*x521))+((x519*x523))+sj2+(((-0.35)*x519))+((x519*x522))+x518);
evalcond[1]=((1.15)+(((-1.0)*x520*x525))+(((-1.0)*x519*x521))+(((-1.0)*x520*x526))+(((0.35)*x520))+cj2+(((-1.0)*x524)));
evalcond[2]=(((sj2*x520))+(((1.15)*x519))+(((-1.0)*x519*x524))+((x518*x520))+((cj2*x519))+(((-1.0)*x521)));
evalcond[3]=((-0.443319)+(((2.3)*pz*x519))+((x523*x527))+(((0.7)*x522))+(((-0.805)*x520))+(((-1.0)*(1.0)*pp))+(((0.7)*x523))+((x522*x527)));
evalcond[4]=((0.35)+(((-1.0)*sj2*x519))+(((1.15)*x520))+(((-1.0)*x525))+(((-1.0)*x518*x519))+(((-1.0)*x526))+(((-1.0)*x520*x524))+((cj2*x520)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x110=((((-1.0)*(1.0)*cj1*cj2))+((sj1*sj2)));
IkReal x111=(cj1*sj2);
IkReal x112=(cj2*sj1);
IkReal x113=(x112+x111);
IkReal x114=(cj0*x113);
IkReal x115=(sj0*x113);
IkReal x116=((1.0)*cj0);
IkReal x117=((((-1.0)*x111))+(((-1.0)*x112)));
IkReal x118=(cj0*x110);
IkReal x119=(sj0*x110);
new_r00=(((r20*x110))+((r10*x115))+((r00*x114)));
new_r01=(((r11*x115))+((r01*x114))+((r21*x110)));
new_r02=(((r22*x110))+((r12*x115))+((r02*x114)));
new_r10=((((-1.0)*r10*x116))+((r00*sj0)));
new_r11=((((-1.0)*r11*x116))+((r01*sj0)));
new_r12=(((r02*sj0))+(((-1.0)*r12*x116)));
new_r20=(((r00*x118))+((r20*x117))+((r10*x119)));
new_r21=(((r01*x118))+((r21*x117))+((r11*x119)));
new_r22=(((r02*x118))+((r12*x119))+((r22*x117)));
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
cj4array[0]=new_r22;
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
IkReal j3eval[2];
IkReal x120=((((-1.0)*(1.0)*cj1*cj2))+((sj1*sj2)));
IkReal x121=(cj1*sj2);
IkReal x122=(cj2*sj1);
IkReal x123=(x121+x122);
IkReal x124=(cj0*x123);
IkReal x125=(sj0*x123);
IkReal x126=((1.0)*cj0);
IkReal x127=x117;
IkReal x128=(cj0*x120);
IkReal x129=(sj0*x120);
new_r00=(((r10*x125))+((r20*x120))+((r00*x124)));
new_r01=(((r01*x124))+((r21*x120))+((r11*x125)));
new_r02=(((r12*x125))+((r02*x124))+((r22*x120)));
new_r10=(((r00*sj0))+(((-1.0)*r10*x126)));
new_r11=((((-1.0)*r11*x126))+((r01*sj0)));
new_r12=((((-1.0)*r12*x126))+((r02*sj0)));
new_r20=(((r10*x129))+((r20*x127))+((r00*x128)));
new_r21=(((r11*x129))+((r21*x127))+((r01*x128)));
new_r22=(((r02*x128))+((r12*x129))+((r22*x127)));
j3eval[0]=sj4;
j3eval[1]=IKsign(sj4);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[1];
IkReal x130=((((-1.0)*(1.0)*cj1*cj2))+((sj1*sj2)));
IkReal x131=(cj1*sj2);
IkReal x132=(cj2*sj1);
IkReal x133=(x131+x132);
IkReal x134=(cj0*x133);
IkReal x135=(sj0*x133);
IkReal x136=((1.0)*cj0);
IkReal x137=x117;
IkReal x138=(cj0*x130);
IkReal x139=(sj0*x130);
new_r00=(((r10*x135))+((r20*x130))+((r00*x134)));
new_r01=(((r21*x130))+((r01*x134))+((r11*x135)));
new_r02=(((r22*x130))+((r02*x134))+((r12*x135)));
new_r10=(((r00*sj0))+(((-1.0)*r10*x136)));
new_r11=((((-1.0)*r11*x136))+((r01*sj0)));
new_r12=(((r02*sj0))+(((-1.0)*r12*x136)));
new_r20=(((r20*x137))+((r10*x139))+((r00*x138)));
new_r21=(((r11*x139))+((r21*x137))+((r01*x138)));
new_r22=(((r12*x139))+((r22*x137))+((r02*x138)));
j3eval[0]=sj4;
if( IKabs(j3eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x141 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x141.valid){
continue;
}
IkReal x140=((-1.0)*(((1.0)*(x141.value))));
j3array[0]=x140;
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+x140);
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*new_r02*(IKsin(j3))))+((new_r12*(IKcos(j3)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x142=((1.0)*new_r01);
if( IKabs(((((-1.0)*(1.0)*new_r00*sj3))+(((-1.0)*cj3*x142)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj3*x142))+((cj3*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*(1.0)*new_r00*sj3))+(((-1.0)*cj3*x142))))+IKsqr(((((-1.0)*sj3*x142))+((cj3*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*(1.0)*new_r00*sj3))+(((-1.0)*cj3*x142))), ((((-1.0)*sj3*x142))+((cj3*new_r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x143=IKsin(j5);
IkReal x144=(cj3*x143);
IkReal x145=IKcos(j5);
IkReal x146=((1.0)*x145);
IkReal x147=((-1.0)*x146);
IkReal x148=((1.0)*sj3);
IkReal x149=((((-1.0)*cj3*x146))+((sj3*x143)));
evalcond[0]=(x143+((new_r11*sj3))+((cj3*new_r01)));
evalcond[1]=(x144+new_r01+((sj3*x145)));
evalcond[2]=(((new_r10*sj3))+x147+((cj3*new_r00)));
evalcond[3]=(((cj3*new_r10))+(((-1.0)*x143))+(((-1.0)*new_r00*x148)));
evalcond[4]=(((cj3*new_r11))+x147+(((-1.0)*new_r01*x148)));
evalcond[5]=(x149+new_r00);
evalcond[6]=(x149+new_r11);
evalcond[7]=((((-1.0)*x144))+new_r10+(((-1.0)*x145*x148)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
CheckValue<IkReal> x151 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x151.valid){
continue;
}
IkReal x150=((-1.0)*(((1.0)*(x151.value))));
j3array[0]=x150;
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((3.14159265358979)+x150);
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*(1.0)*new_r02*(IKsin(j3))))+((new_r12*(IKcos(j3)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x152=((1.0)*new_r00);
if( IKabs((((cj3*new_r01))+(((-1.0)*sj3*x152)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*(1.0)*new_r01*sj3))+(((-1.0)*cj3*x152)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj3*new_r01))+(((-1.0)*sj3*x152))))+IKsqr(((((-1.0)*(1.0)*new_r01*sj3))+(((-1.0)*cj3*x152))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj3*new_r01))+(((-1.0)*sj3*x152))), ((((-1.0)*(1.0)*new_r01*sj3))+(((-1.0)*cj3*x152))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x153=IKcos(j5);
IkReal x154=IKsin(j5);
IkReal x155=((1.0)*x154);
IkReal x156=((-1.0)*x155);
IkReal x157=(cj3*x153);
IkReal x158=((1.0)*sj3);
IkReal x159=(((sj3*x153))+(((-1.0)*cj3*x155)));
evalcond[0]=(((new_r10*sj3))+x153+((cj3*new_r00)));
evalcond[1]=(x156+((new_r11*sj3))+((cj3*new_r01)));
evalcond[2]=(((sj3*x154))+x157+new_r00);
evalcond[3]=(((cj3*new_r10))+x156+(((-1.0)*new_r00*x158)));
evalcond[4]=(((cj3*new_r11))+(((-1.0)*new_r01*x158))+(((-1.0)*x153)));
evalcond[5]=(x159+new_r01);
evalcond[6]=(x159+new_r10);
evalcond[7]=((((-1.0)*x157))+(((-1.0)*x154*x158))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3, j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x161=IKPowWithIntegerCheck(sj4,-1);
if(!x161.valid){
continue;
}
IkReal x160=x161.value;
CheckValue<IkReal> x162=IKPowWithIntegerCheck(new_r12,-1);
if(!x162.valid){
continue;
}
if( IKabs((x160*(x162.value)*(((1.0)+(((-1.0)*(1.0)*(new_r02*new_r02)))+(((-1.0)*(1.0)*(cj4*cj4))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x160)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x160*(x162.value)*(((1.0)+(((-1.0)*(1.0)*(new_r02*new_r02)))+(((-1.0)*(1.0)*(cj4*cj4)))))))+IKsqr((new_r02*x160))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2((x160*(x162.value)*(((1.0)+(((-1.0)*(1.0)*(new_r02*new_r02)))+(((-1.0)*(1.0)*(cj4*cj4)))))), (new_r02*x160));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x163=IKcos(j3);
IkReal x164=((1.0)*sj4);
IkReal x165=(x163*x164);
IkReal x166=IKsin(j3);
IkReal x167=(x164*x166);
IkReal x168=(new_r02*x163);
IkReal x169=(new_r12*x166);
IkReal x170=((1.0)*cj4);
evalcond[0]=(new_r02+(((-1.0)*x165)));
evalcond[1]=(new_r12+(((-1.0)*x167)));
evalcond[2]=((((-1.0)*new_r02*x166))+((new_r12*x163)));
evalcond[3]=((((-1.0)*x164))+x169+x168);
evalcond[4]=((((-1.0)*x168*x170))+((new_r22*sj4))+(((-1.0)*x169*x170)));
evalcond[5]=((((-1.0)*new_r00*x165))+(((-1.0)*new_r10*x167))+(((-1.0)*new_r20*x170)));
evalcond[6]=((((-1.0)*new_r11*x167))+(((-1.0)*new_r01*x165))+(((-1.0)*new_r21*x170)));
evalcond[7]=((1.0)+(((-1.0)*x164*x169))+(((-1.0)*x164*x168))+(((-1.0)*new_r22*x170)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[2];
IkReal x171=((((-1.0)*(1.0)*cj1*cj2))+((sj1*sj2)));
IkReal x172=(cj1*sj2);
IkReal x173=(cj2*sj1);
IkReal x174=(x173+x172);
IkReal x175=(cj0*x174);
IkReal x176=(sj0*x174);
IkReal x177=((1.0)*cj0);
IkReal x178=x117;
IkReal x179=(cj0*x171);
IkReal x180=(sj0*x171);
new_r00=(((r20*x171))+((r10*x176))+((r00*x175)));
new_r01=(((r01*x175))+((r21*x171))+((r11*x176)));
new_r02=(((r12*x176))+((r22*x171))+((r02*x175)));
new_r10=(((r00*sj0))+(((-1.0)*r10*x177)));
new_r11=(((r01*sj0))+(((-1.0)*r11*x177)));
new_r12=(((r02*sj0))+(((-1.0)*r12*x177)));
new_r20=(((r10*x180))+((r00*x179))+((r20*x178)));
new_r21=(((r11*x180))+((r01*x179))+((r21*x178)));
new_r22=(((r22*x178))+((r02*x179))+((r12*x180)));
j5eval[0]=sj4;
j5eval[1]=IKsign(sj4);
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x181=((((-1.0)*(1.0)*cj1*cj2))+((sj1*sj2)));
IkReal x182=(cj1*sj2);
IkReal x183=(cj2*sj1);
IkReal x184=(x183+x182);
IkReal x185=(cj0*x184);
IkReal x186=(sj0*x184);
IkReal x187=((1.0)*cj0);
IkReal x188=x117;
IkReal x189=(cj0*x181);
IkReal x190=(sj0*x181);
new_r00=(((r20*x181))+((r10*x186))+((r00*x185)));
new_r01=(((r11*x186))+((r01*x185))+((r21*x181)));
new_r02=(((r12*x186))+((r02*x185))+((r22*x181)));
new_r10=(((r00*sj0))+(((-1.0)*r10*x187)));
new_r11=((((-1.0)*r11*x187))+((r01*sj0)));
new_r12=(((r02*sj0))+(((-1.0)*r12*x187)));
new_r20=(((r00*x189))+((r20*x188))+((r10*x190)));
new_r21=(((r21*x188))+((r11*x190))+((r01*x189)));
new_r22=(((r12*x190))+((r22*x188))+((r02*x189)));
j5eval[0]=sj3;
j5eval[1]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
IkReal x191=((((-1.0)*(1.0)*cj1*cj2))+((sj1*sj2)));
IkReal x192=(cj1*sj2);
IkReal x193=(cj2*sj1);
IkReal x194=(x192+x193);
IkReal x195=(cj0*x194);
IkReal x196=(sj0*x194);
IkReal x197=((1.0)*cj0);
IkReal x198=x117;
IkReal x199=(cj0*x191);
IkReal x200=(sj0*x191);
new_r00=(((r20*x191))+((r00*x195))+((r10*x196)));
new_r01=(((r21*x191))+((r11*x196))+((r01*x195)));
new_r02=(((r22*x191))+((r02*x195))+((r12*x196)));
new_r10=(((r00*sj0))+(((-1.0)*r10*x197)));
new_r11=((((-1.0)*r11*x197))+((r01*sj0)));
new_r12=((((-1.0)*r12*x197))+((r02*sj0)));
new_r20=(((r20*x198))+((r00*x199))+((r10*x200)));
new_r21=(((r11*x200))+((r21*x198))+((r01*x199)));
new_r22=(((r12*x200))+((r22*x198))+((r02*x199)));
j5eval[0]=cj3;
j5eval[1]=cj4;
j5eval[2]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x201=((1.0)*cj4);
IkReal x202=((((-1.0)*x201))+new_r22);
IkReal x203=((1.0)*sj4);
IkReal x204=(new_r12+(((-1.0)*x203)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=x202;
evalcond[2]=x202;
evalcond[3]=new_r02;
evalcond[4]=x204;
evalcond[5]=x204;
evalcond[6]=(((new_r22*sj4))+(((-1.0)*new_r12*x201)));
evalcond[7]=((((-1.0)*new_r20*x201))+(((-1.0)*new_r10*x203)));
evalcond[8]=((((-1.0)*new_r21*x201))+(((-1.0)*new_r11*x203)));
evalcond[9]=((1.0)+(((-1.0)*new_r12*x203))+(((-1.0)*new_r22*x201)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x205=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x205.valid){
continue;
}
CheckValue<IkReal> x206 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*(((1.0)*new_r20))),IKFAST_ATAN2_MAGTHRESH);
if(!x206.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x205.value)))+(x206.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x207=IKcos(j5);
IkReal x208=IKsin(j5);
IkReal x209=((1.0)*x208);
IkReal x210=((1.0)*new_r22);
IkReal x211=((-1.0)*x209);
evalcond[0]=(((new_r12*x207))+new_r20);
evalcond[1]=(((new_r22*x208))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x209))+new_r21);
evalcond[3]=((((-1.0)*x207*x210))+new_r10);
evalcond[4]=((((-1.0)*(1.0)*new_r00))+x211);
evalcond[5]=((((-1.0)*(1.0)*new_r01))+(((-1.0)*x207)));
evalcond[6]=((((-1.0)*new_r10*x210))+((new_r12*new_r20))+x207);
evalcond[7]=(((new_r12*new_r21))+(((-1.0)*new_r11*x210))+x211);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x212=((1.0)*cj4);
IkReal x213=((((-1.0)*x212))+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=x213;
evalcond[2]=x213;
evalcond[3]=new_r02;
evalcond[4]=(sj4+new_r12);
evalcond[5]=((((-1.0)*(1.0)*new_r12))+(((-1.0)*(1.0)*sj4)));
evalcond[6]=(((new_r22*sj4))+((cj4*new_r12)));
evalcond[7]=((((-1.0)*new_r20*x212))+((new_r10*sj4)));
evalcond[8]=((((-1.0)*new_r21*x212))+((new_r11*sj4)));
evalcond[9]=((1.0)+(((-1.0)*new_r22*x212))+((new_r12*sj4)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r00, new_r01);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x214=IKsin(j5);
IkReal x215=((-1.0)*x214);
IkReal x216=IKcos(j5);
IkReal x217=((1.0)*x216);
IkReal x218=((1.0)*new_r12);
evalcond[0]=(((new_r12*x214))+new_r21);
evalcond[1]=(x215+new_r00);
evalcond[2]=((((-1.0)*x217))+new_r01);
evalcond[3]=((((-1.0)*x216*x218))+new_r20);
evalcond[4]=((((-1.0)*(1.0)*new_r11))+((new_r22*x214)));
evalcond[5]=((((-1.0)*(1.0)*new_r10))+(((-1.0)*new_r22*x217)));
evalcond[6]=((((-1.0)*new_r20*x218))+((new_r10*new_r22))+x216);
evalcond[7]=(((new_r11*new_r22))+x215+(((-1.0)*new_r21*x218)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x219=((1.0)*cj3);
IkReal x220=((1.0)*sj3);
IkReal x221=((((-1.0)*new_r02*x220))+((cj3*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*x219))+new_r02);
evalcond[3]=((((-1.0)*x220))+new_r12);
evalcond[4]=x221;
evalcond[5]=x221;
evalcond[6]=((-1.0)+((new_r12*sj3))+((cj3*new_r02)));
evalcond[7]=(((new_r11*sj3))+((cj3*new_r01)));
evalcond[8]=(((new_r10*sj3))+((cj3*new_r00)));
evalcond[9]=((((-1.0)*new_r00*x219))+(((-1.0)*new_r10*x220)));
evalcond[10]=((((-1.0)*new_r11*x220))+(((-1.0)*new_r01*x219)));
evalcond[11]=((1.0)+(((-1.0)*new_r12*x220))+(((-1.0)*new_r02*x219)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*(((1.0)*new_r20)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*(((1.0)*new_r20))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r21, ((-1.0)*(((1.0)*new_r20))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x222=IKcos(j5);
IkReal x223=IKsin(j5);
IkReal x224=((1.0)*x223);
IkReal x225=((-1.0)*x224);
IkReal x226=((1.0)*x222);
IkReal x227=((1.0)*new_r12);
evalcond[0]=(x222+new_r20);
evalcond[1]=(x225+new_r21);
evalcond[2]=(((new_r12*x222))+new_r01);
evalcond[3]=(((new_r12*x223))+new_r00);
evalcond[4]=((((-1.0)*new_r02*x226))+new_r11);
evalcond[5]=((((-1.0)*new_r02*x224))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x227))+((new_r02*new_r10))+x225);
evalcond[7]=(((new_r02*new_r11))+(((-1.0)*x226))+(((-1.0)*new_r01*x227)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x228=((((-1.0)*(1.0)*new_r02*sj3))+((cj3*new_r12)));
IkReal x229=((1.0)+((new_r12*sj3))+((cj3*new_r02)));
IkReal x230=(((new_r11*sj3))+((cj3*new_r01)));
IkReal x231=(((new_r10*sj3))+((cj3*new_r00)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj3+new_r02);
evalcond[3]=(sj3+new_r12);
evalcond[4]=x228;
evalcond[5]=x228;
evalcond[6]=x229;
evalcond[7]=x230;
evalcond[8]=x231;
evalcond[9]=x231;
evalcond[10]=x230;
evalcond[11]=x229;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(((-1.0)*(((1.0)*new_r21)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((1.0)*new_r21))))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*(((1.0)*new_r21))), new_r20);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x232=IKsin(j5);
IkReal x233=IKcos(j5);
IkReal x234=((1.0)*x233);
IkReal x235=((-1.0)*x234);
IkReal x236=((1.0)*x232);
IkReal x237=((1.0)*new_r02);
evalcond[0]=(new_r21+x232);
evalcond[1]=(new_r20+x235);
evalcond[2]=(((new_r02*x233))+new_r11);
evalcond[3]=(((new_r02*x232))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x234))+new_r01);
evalcond[5]=(new_r00+(((-1.0)*new_r12*x236)));
evalcond[6]=(((new_r00*new_r12))+(((-1.0)*new_r10*x237))+(((-1.0)*x236)));
evalcond[7]=(((new_r01*new_r12))+(((-1.0)*new_r11*x237))+x235);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x238=((((-1.0)*(1.0)*new_r02*sj3))+((cj3*new_r12)));
IkReal x239=(cj3*new_r02);
IkReal x240=(new_r12*sj3);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x238;
evalcond[7]=x238;
evalcond[8]=(x240+x239);
evalcond[9]=((((-1.0)*x239))+(((-1.0)*x240)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x241=((1.0)*new_r01);
if( IKabs(((((-1.0)*(1.0)*new_r00*sj3))+(((-1.0)*cj3*x241)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj3*x241))+((cj3*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*(1.0)*new_r00*sj3))+(((-1.0)*cj3*x241))))+IKsqr(((((-1.0)*sj3*x241))+((cj3*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*(1.0)*new_r00*sj3))+(((-1.0)*cj3*x241))), ((((-1.0)*sj3*x241))+((cj3*new_r00))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x242=IKsin(j5);
IkReal x243=(cj3*x242);
IkReal x244=IKcos(j5);
IkReal x245=((1.0)*x244);
IkReal x246=((-1.0)*x245);
IkReal x247=((1.0)*sj3);
IkReal x248=(((sj3*x242))+(((-1.0)*cj3*x245)));
evalcond[0]=(((new_r11*sj3))+x242+((cj3*new_r01)));
evalcond[1]=(x243+((sj3*x244))+new_r01);
evalcond[2]=(((new_r10*sj3))+((cj3*new_r00))+x246);
evalcond[3]=(((cj3*new_r10))+(((-1.0)*x242))+(((-1.0)*new_r00*x247)));
evalcond[4]=(((cj3*new_r11))+x246+(((-1.0)*new_r01*x247)));
evalcond[5]=(x248+new_r00);
evalcond[6]=(x248+new_r11);
evalcond[7]=((((-1.0)*x243))+(((-1.0)*x244*x247))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x249=((((-1.0)*(1.0)*new_r02*sj3))+((cj3*new_r12)));
IkReal x250=(((new_r12*sj3))+((cj3*new_r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x249;
evalcond[7]=x249;
evalcond[8]=x250;
evalcond[9]=x250;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x251=((1.0)*new_r00);
if( IKabs(((((-1.0)*sj3*x251))+((cj3*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*(1.0)*new_r01*sj3))+(((-1.0)*cj3*x251)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj3*x251))+((cj3*new_r01))))+IKsqr(((((-1.0)*(1.0)*new_r01*sj3))+(((-1.0)*cj3*x251))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*sj3*x251))+((cj3*new_r01))), ((((-1.0)*(1.0)*new_r01*sj3))+(((-1.0)*cj3*x251))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x252=IKcos(j5);
IkReal x253=IKsin(j5);
IkReal x254=((1.0)*x253);
IkReal x255=((-1.0)*x254);
IkReal x256=(cj3*x252);
IkReal x257=((1.0)*sj3);
IkReal x258=((((-1.0)*cj3*x254))+((sj3*x252)));
evalcond[0]=(((new_r10*sj3))+((cj3*new_r00))+x252);
evalcond[1]=(((new_r11*sj3))+((cj3*new_r01))+x255);
evalcond[2]=(((sj3*x253))+x256+new_r00);
evalcond[3]=(((cj3*new_r10))+(((-1.0)*new_r00*x257))+x255);
evalcond[4]=(((cj3*new_r11))+(((-1.0)*x252))+(((-1.0)*new_r01*x257)));
evalcond[5]=(x258+new_r01);
evalcond[6]=(x258+new_r10);
evalcond[7]=((((-1.0)*x253*x257))+new_r11+(((-1.0)*x256)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x259=((1.0)*cj4);
IkReal x260=((((-1.0)*x259))+new_r22);
IkReal x261=((1.0)*sj4);
IkReal x262=((((-1.0)*x261))+new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=x260;
evalcond[2]=x260;
evalcond[3]=x262;
evalcond[4]=new_r12;
evalcond[5]=x262;
evalcond[6]=(((new_r22*sj4))+(((-1.0)*new_r02*x259)));
evalcond[7]=((((-1.0)*new_r00*x261))+(((-1.0)*new_r20*x259)));
evalcond[8]=((((-1.0)*new_r01*x261))+(((-1.0)*new_r21*x259)));
evalcond[9]=((1.0)+(((-1.0)*new_r22*x259))+(((-1.0)*new_r02*x261)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r10, new_r11);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x263=IKcos(j5);
IkReal x264=IKsin(j5);
IkReal x265=((1.0)*x264);
IkReal x266=((-1.0)*x265);
IkReal x267=((1.0)*new_r22);
evalcond[0]=(((new_r02*x263))+new_r20);
evalcond[1]=(x266+new_r10);
evalcond[2]=((((-1.0)*x263))+new_r11);
evalcond[3]=(((new_r22*x264))+new_r01);
evalcond[4]=((((-1.0)*new_r02*x265))+new_r21);
evalcond[5]=((((-1.0)*x263*x267))+new_r00);
evalcond[6]=((((-1.0)*new_r00*x267))+((new_r02*new_r20))+x263);
evalcond[7]=(((new_r02*new_r21))+x266+(((-1.0)*new_r01*x267)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x268=((1.0)*cj4);
IkReal x269=((((-1.0)*x268))+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=x269;
evalcond[2]=x269;
evalcond[3]=(sj4+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*(1.0)*sj4))+(((-1.0)*(1.0)*new_r02)));
evalcond[6]=(((new_r22*sj4))+((cj4*new_r02)));
evalcond[7]=(((new_r00*sj4))+(((-1.0)*new_r20*x268)));
evalcond[8]=((((-1.0)*new_r21*x268))+((new_r01*sj4)));
evalcond[9]=((1.0)+((new_r02*sj4))+(((-1.0)*new_r22*x268)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x270 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*new_r21)))),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x270.valid){
continue;
}
CheckValue<IkReal> x271=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x271.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x270.value)+(((1.5707963267949)*(x271.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x272=IKsin(j5);
IkReal x273=IKcos(j5);
IkReal x274=((1.0)*new_r02);
IkReal x275=((-1.0)*x272);
IkReal x276=((1.0)*x273);
evalcond[0]=(((new_r02*x272))+new_r21);
evalcond[1]=((((-1.0)*x273*x274))+new_r20);
evalcond[2]=((((-1.0)*(1.0)*new_r10))+x275);
evalcond[3]=((((-1.0)*x276))+(((-1.0)*(1.0)*new_r11)));
evalcond[4]=((((-1.0)*(1.0)*new_r01))+((new_r22*x272)));
evalcond[5]=((((-1.0)*new_r22*x276))+(((-1.0)*(1.0)*new_r00)));
evalcond[6]=((((-1.0)*new_r20*x274))+x273+((new_r00*new_r22)));
evalcond[7]=(((new_r01*new_r22))+x275+(((-1.0)*new_r21*x274)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x278=IKPowWithIntegerCheck(sj4,-1);
if(!x278.valid){
continue;
}
IkReal x277=x278.value;
CheckValue<IkReal> x279=IKPowWithIntegerCheck(cj3,-1);
if(!x279.valid){
continue;
}
CheckValue<IkReal> x280=IKPowWithIntegerCheck(cj4,-1);
if(!x280.valid){
continue;
}
if( IKabs((x277*(x279.value)*(x280.value)*(((((-1.0)*(1.0)*new_r01*sj4))+((new_r20*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x277)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x277*(x279.value)*(x280.value)*(((((-1.0)*(1.0)*new_r01*sj4))+((new_r20*sj3))))))+IKsqr(((-1.0)*new_r20*x277))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((x277*(x279.value)*(x280.value)*(((((-1.0)*(1.0)*new_r01*sj4))+((new_r20*sj3))))), ((-1.0)*new_r20*x277));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x281=IKcos(j5);
IkReal x282=IKsin(j5);
IkReal x283=((1.0)*x282);
IkReal x284=(cj3*new_r01);
IkReal x285=(new_r11*sj3);
IkReal x286=(cj4*x282);
IkReal x287=((1.0)*sj3);
IkReal x288=((-1.0)*x283);
IkReal x289=((1.0)*x281);
IkReal x290=(cj3*new_r00);
IkReal x291=(new_r10*sj3);
IkReal x292=(cj3*x289);
IkReal x293=((1.0)*cj4);
evalcond[0]=(((sj4*x281))+new_r20);
evalcond[1]=((((-1.0)*sj4*x283))+new_r21);
evalcond[2]=(x285+x284+x286);
evalcond[3]=(((cj3*new_r10))+(((-1.0)*new_r00*x287))+x288);
evalcond[4]=(((cj3*new_r11))+(((-1.0)*new_r01*x287))+(((-1.0)*x289)));
evalcond[5]=(((cj3*x286))+((sj3*x281))+new_r01);
evalcond[6]=(x291+x290+(((-1.0)*cj4*x289)));
evalcond[7]=(((sj3*x282))+(((-1.0)*cj4*x292))+new_r00);
evalcond[8]=(((sj3*x286))+new_r11+(((-1.0)*x292)));
evalcond[9]=((((-1.0)*cj4*x281*x287))+(((-1.0)*cj3*x283))+new_r10);
evalcond[10]=(((new_r20*sj4))+(((-1.0)*x290*x293))+x281+(((-1.0)*x291*x293)));
evalcond[11]=((((-1.0)*x285*x293))+(((-1.0)*x284*x293))+x288+((new_r21*sj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x296=IKPowWithIntegerCheck(sj4,-1);
if(!x296.valid){
continue;
}
IkReal x294=x296.value;
IkReal x295=((1.0)*new_r20);
CheckValue<IkReal> x297=IKPowWithIntegerCheck(sj3,-1);
if(!x297.valid){
continue;
}
if( IKabs((x294*(x297.value)*(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj3*cj4*x295)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*x294*x295)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x294*(x297.value)*(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj3*cj4*x295))))))+IKsqr(((-1.0)*x294*x295))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((x294*(x297.value)*(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj3*cj4*x295))))), ((-1.0)*x294*x295));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x298=IKcos(j5);
IkReal x299=IKsin(j5);
IkReal x300=((1.0)*x299);
IkReal x301=(cj3*new_r01);
IkReal x302=(new_r11*sj3);
IkReal x303=(cj4*x299);
IkReal x304=((1.0)*sj3);
IkReal x305=((-1.0)*x300);
IkReal x306=((1.0)*x298);
IkReal x307=(cj3*new_r00);
IkReal x308=(new_r10*sj3);
IkReal x309=(cj3*x306);
IkReal x310=((1.0)*cj4);
evalcond[0]=(((sj4*x298))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*sj4*x300)));
evalcond[2]=(x301+x303+x302);
evalcond[3]=(((cj3*new_r10))+x305+(((-1.0)*new_r00*x304)));
evalcond[4]=(((cj3*new_r11))+(((-1.0)*x306))+(((-1.0)*new_r01*x304)));
evalcond[5]=(((sj3*x298))+((cj3*x303))+new_r01);
evalcond[6]=(x307+x308+(((-1.0)*cj4*x306)));
evalcond[7]=(((sj3*x299))+(((-1.0)*cj4*x309))+new_r00);
evalcond[8]=((((-1.0)*x309))+((sj3*x303))+new_r11);
evalcond[9]=((((-1.0)*cj4*x298*x304))+(((-1.0)*cj3*x300))+new_r10);
evalcond[10]=((((-1.0)*x308*x310))+x298+(((-1.0)*x307*x310))+((new_r20*sj4)));
evalcond[11]=((((-1.0)*x302*x310))+(((-1.0)*x301*x310))+x305+((new_r21*sj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x311=IKPowWithIntegerCheck(IKsign(sj4),-1);
if(!x311.valid){
continue;
}
CheckValue<IkReal> x312 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*(((1.0)*new_r20))),IKFAST_ATAN2_MAGTHRESH);
if(!x312.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x311.value)))+(x312.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x313=IKcos(j5);
IkReal x314=IKsin(j5);
IkReal x315=((1.0)*x314);
IkReal x316=(cj3*new_r01);
IkReal x317=(new_r11*sj3);
IkReal x318=(cj4*x314);
IkReal x319=((1.0)*sj3);
IkReal x320=((-1.0)*x315);
IkReal x321=((1.0)*x313);
IkReal x322=(cj3*new_r00);
IkReal x323=(new_r10*sj3);
IkReal x324=(cj3*x321);
IkReal x325=((1.0)*cj4);
evalcond[0]=(((sj4*x313))+new_r20);
evalcond[1]=((((-1.0)*sj4*x315))+new_r21);
evalcond[2]=(x316+x317+x318);
evalcond[3]=(((cj3*new_r10))+(((-1.0)*new_r00*x319))+x320);
evalcond[4]=(((cj3*new_r11))+(((-1.0)*new_r01*x319))+(((-1.0)*x321)));
evalcond[5]=(((sj3*x313))+((cj3*x318))+new_r01);
evalcond[6]=((((-1.0)*cj4*x321))+x322+x323);
evalcond[7]=(((sj3*x314))+(((-1.0)*cj4*x324))+new_r00);
evalcond[8]=(((sj3*x318))+(((-1.0)*x324))+new_r11);
evalcond[9]=((((-1.0)*cj3*x315))+(((-1.0)*cj4*x313*x319))+new_r10);
evalcond[10]=((((-1.0)*x323*x325))+((new_r20*sj4))+x313+(((-1.0)*x322*x325)));
evalcond[11]=(x320+(((-1.0)*x317*x325))+((new_r21*sj4))+(((-1.0)*x316*x325)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
CheckValue<IkReal> x326=IKPowWithIntegerCheck(IKsign(sj4),-1);
if(!x326.valid){
continue;
}
CheckValue<IkReal> x327 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);
if(!x327.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x326.value)))+(x327.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[8];
IkReal x328=IKcos(j3);
IkReal x329=((1.0)*sj4);
IkReal x330=(x328*x329);
IkReal x331=IKsin(j3);
IkReal x332=(x329*x331);
IkReal x333=(new_r02*x328);
IkReal x334=(new_r12*x331);
IkReal x335=((1.0)*cj4);
evalcond[0]=(new_r02+(((-1.0)*x330)));
evalcond[1]=((((-1.0)*x332))+new_r12);
evalcond[2]=(((new_r12*x328))+(((-1.0)*new_r02*x331)));
evalcond[3]=((((-1.0)*x329))+x334+x333);
evalcond[4]=((((-1.0)*x333*x335))+((new_r22*sj4))+(((-1.0)*x334*x335)));
evalcond[5]=((((-1.0)*new_r00*x330))+(((-1.0)*new_r20*x335))+(((-1.0)*new_r10*x332)));
evalcond[6]=((((-1.0)*new_r21*x335))+(((-1.0)*new_r11*x332))+(((-1.0)*new_r01*x330)));
evalcond[7]=((1.0)+(((-1.0)*new_r22*x335))+(((-1.0)*x329*x334))+(((-1.0)*x329*x333)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j5eval[2];
IkReal x336=((((-1.0)*(1.0)*cj1*cj2))+((sj1*sj2)));
IkReal x337=(cj1*sj2);
IkReal x338=(cj2*sj1);
IkReal x339=(x337+x338);
IkReal x340=(cj0*x339);
IkReal x341=(sj0*x339);
IkReal x342=((1.0)*cj0);
IkReal x343=x117;
IkReal x344=(cj0*x336);
IkReal x345=(sj0*x336);
new_r00=(((r10*x341))+((r00*x340))+((r20*x336)));
new_r01=(((r21*x336))+((r01*x340))+((r11*x341)));
new_r02=(((r02*x340))+((r12*x341))+((r22*x336)));
new_r10=(((r00*sj0))+(((-1.0)*r10*x342)));
new_r11=((((-1.0)*r11*x342))+((r01*sj0)));
new_r12=((((-1.0)*r12*x342))+((r02*sj0)));
new_r20=(((r10*x345))+((r20*x343))+((r00*x344)));
new_r21=(((r01*x344))+((r21*x343))+((r11*x345)));
new_r22=(((r02*x344))+((r22*x343))+((r12*x345)));
j5eval[0]=sj4;
j5eval[1]=IKsign(sj4);
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[2];
IkReal x346=((((-1.0)*(1.0)*cj1*cj2))+((sj1*sj2)));
IkReal x347=(cj1*sj2);
IkReal x348=(cj2*sj1);
IkReal x349=(x348+x347);
IkReal x350=(cj0*x349);
IkReal x351=(sj0*x349);
IkReal x352=((1.0)*cj0);
IkReal x353=x117;
IkReal x354=(cj0*x346);
IkReal x355=(sj0*x346);
new_r00=(((r20*x346))+((r10*x351))+((r00*x350)));
new_r01=(((r21*x346))+((r11*x351))+((r01*x350)));
new_r02=(((r12*x351))+((r02*x350))+((r22*x346)));
new_r10=(((r00*sj0))+(((-1.0)*r10*x352)));
new_r11=((((-1.0)*r11*x352))+((r01*sj0)));
new_r12=((((-1.0)*r12*x352))+((r02*sj0)));
new_r20=(((r10*x355))+((r00*x354))+((r20*x353)));
new_r21=(((r11*x355))+((r01*x354))+((r21*x353)));
new_r22=(((r12*x355))+((r22*x353))+((r02*x354)));
j5eval[0]=sj3;
j5eval[1]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  )
{
{
IkReal j5eval[3];
IkReal x356=((((-1.0)*(1.0)*cj1*cj2))+((sj1*sj2)));
IkReal x357=(cj1*sj2);
IkReal x358=(cj2*sj1);
IkReal x359=(x358+x357);
IkReal x360=(cj0*x359);
IkReal x361=(sj0*x359);
IkReal x362=((1.0)*cj0);
IkReal x363=x117;
IkReal x364=(cj0*x356);
IkReal x365=(sj0*x356);
new_r00=(((r00*x360))+((r10*x361))+((r20*x356)));
new_r01=(((r21*x356))+((r01*x360))+((r11*x361)));
new_r02=(((r22*x356))+((r12*x361))+((r02*x360)));
new_r10=(((r00*sj0))+(((-1.0)*r10*x362)));
new_r11=((((-1.0)*r11*x362))+((r01*sj0)));
new_r12=((((-1.0)*r12*x362))+((r02*sj0)));
new_r20=(((r00*x364))+((r10*x365))+((r20*x363)));
new_r21=(((r21*x363))+((r01*x364))+((r11*x365)));
new_r22=(((r02*x364))+((r22*x363))+((r12*x365)));
j5eval[0]=cj3;
j5eval[1]=cj4;
j5eval[2]=sj4;
if( IKabs(j5eval[0]) < 0.0000010000000000  || IKabs(j5eval[1]) < 0.0000010000000000  || IKabs(j5eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x366=((1.0)*cj4);
IkReal x367=((((-1.0)*x366))+new_r22);
IkReal x368=((1.0)*sj4);
IkReal x369=((((-1.0)*x368))+new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=x367;
evalcond[2]=x367;
evalcond[3]=new_r02;
evalcond[4]=x369;
evalcond[5]=x369;
evalcond[6]=((((-1.0)*new_r12*x366))+((new_r22*sj4)));
evalcond[7]=((((-1.0)*new_r10*x368))+(((-1.0)*new_r20*x366)));
evalcond[8]=((((-1.0)*new_r21*x366))+(((-1.0)*new_r11*x368)));
evalcond[9]=((1.0)+(((-1.0)*new_r12*x368))+(((-1.0)*new_r22*x366)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x370=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x370.valid){
continue;
}
CheckValue<IkReal> x371 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*(((1.0)*new_r20))),IKFAST_ATAN2_MAGTHRESH);
if(!x371.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x370.value)))+(x371.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x372=IKcos(j5);
IkReal x373=IKsin(j5);
IkReal x374=((1.0)*x373);
IkReal x375=((1.0)*new_r22);
IkReal x376=((-1.0)*x374);
evalcond[0]=(((new_r12*x372))+new_r20);
evalcond[1]=(((new_r22*x373))+new_r11);
evalcond[2]=((((-1.0)*new_r12*x374))+new_r21);
evalcond[3]=((((-1.0)*x372*x375))+new_r10);
evalcond[4]=((((-1.0)*(1.0)*new_r00))+x376);
evalcond[5]=((((-1.0)*x372))+(((-1.0)*(1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r10*x375))+((new_r12*new_r20))+x372);
evalcond[7]=(((new_r12*new_r21))+(((-1.0)*new_r11*x375))+x376);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x377=((1.0)*cj4);
IkReal x378=((((-1.0)*x377))+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
evalcond[1]=x378;
evalcond[2]=x378;
evalcond[3]=new_r02;
evalcond[4]=(sj4+new_r12);
evalcond[5]=((((-1.0)*(1.0)*new_r12))+(((-1.0)*(1.0)*sj4)));
evalcond[6]=(((new_r22*sj4))+((cj4*new_r12)));
evalcond[7]=((((-1.0)*new_r20*x377))+((new_r10*sj4)));
evalcond[8]=((((-1.0)*new_r21*x377))+((new_r11*sj4)));
evalcond[9]=((1.0)+(((-1.0)*new_r22*x377))+((new_r12*sj4)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r00, new_r01);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x379=IKsin(j5);
IkReal x380=((-1.0)*x379);
IkReal x381=IKcos(j5);
IkReal x382=((1.0)*x381);
IkReal x383=((1.0)*new_r12);
evalcond[0]=(((new_r12*x379))+new_r21);
evalcond[1]=(x380+new_r00);
evalcond[2]=((((-1.0)*x382))+new_r01);
evalcond[3]=((((-1.0)*x381*x383))+new_r20);
evalcond[4]=(((new_r22*x379))+(((-1.0)*(1.0)*new_r11)));
evalcond[5]=((((-1.0)*(1.0)*new_r10))+(((-1.0)*new_r22*x382)));
evalcond[6]=(((new_r10*new_r22))+(((-1.0)*new_r20*x383))+x381);
evalcond[7]=(((new_r11*new_r22))+(((-1.0)*new_r21*x383))+x380);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x384=((1.0)*cj3);
IkReal x385=((1.0)*sj3);
IkReal x386=((((-1.0)*new_r02*x385))+((cj3*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*x384))+new_r02);
evalcond[3]=((((-1.0)*x385))+new_r12);
evalcond[4]=x386;
evalcond[5]=x386;
evalcond[6]=((-1.0)+((new_r12*sj3))+((cj3*new_r02)));
evalcond[7]=(((new_r11*sj3))+((cj3*new_r01)));
evalcond[8]=(((new_r10*sj3))+((cj3*new_r00)));
evalcond[9]=((((-1.0)*new_r00*x384))+(((-1.0)*new_r10*x385)));
evalcond[10]=((((-1.0)*new_r01*x384))+(((-1.0)*new_r11*x385)));
evalcond[11]=((1.0)+(((-1.0)*new_r02*x384))+(((-1.0)*new_r12*x385)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*(((1.0)*new_r20)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*(((1.0)*new_r20))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r21, ((-1.0)*(((1.0)*new_r20))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x387=IKcos(j5);
IkReal x388=IKsin(j5);
IkReal x389=((1.0)*x388);
IkReal x390=((-1.0)*x389);
IkReal x391=((1.0)*x387);
IkReal x392=((1.0)*new_r12);
evalcond[0]=(x387+new_r20);
evalcond[1]=(x390+new_r21);
evalcond[2]=(((new_r12*x387))+new_r01);
evalcond[3]=(((new_r12*x388))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*new_r02*x391)));
evalcond[5]=(new_r10+(((-1.0)*new_r02*x389)));
evalcond[6]=(x390+(((-1.0)*new_r00*x392))+((new_r02*new_r10)));
evalcond[7]=(((new_r02*new_r11))+(((-1.0)*new_r01*x392))+(((-1.0)*x391)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x393=((((-1.0)*(1.0)*new_r02*sj3))+((cj3*new_r12)));
IkReal x394=((1.0)+((new_r12*sj3))+((cj3*new_r02)));
IkReal x395=(((new_r11*sj3))+((cj3*new_r01)));
IkReal x396=(((new_r10*sj3))+((cj3*new_r00)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj3+new_r02);
evalcond[3]=(sj3+new_r12);
evalcond[4]=x393;
evalcond[5]=x393;
evalcond[6]=x394;
evalcond[7]=x395;
evalcond[8]=x396;
evalcond[9]=x396;
evalcond[10]=x395;
evalcond[11]=x394;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(((-1.0)*(((1.0)*new_r21)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*(((1.0)*new_r21))))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((-1.0)*(((1.0)*new_r21))), new_r20);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x397=IKsin(j5);
IkReal x398=IKcos(j5);
IkReal x399=((1.0)*x398);
IkReal x400=((-1.0)*x399);
IkReal x401=((1.0)*x397);
IkReal x402=((1.0)*new_r02);
evalcond[0]=(x397+new_r21);
evalcond[1]=(x400+new_r20);
evalcond[2]=(((new_r02*x398))+new_r11);
evalcond[3]=(((new_r02*x397))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x399))+new_r01);
evalcond[5]=(new_r00+(((-1.0)*new_r12*x401)));
evalcond[6]=(((new_r00*new_r12))+(((-1.0)*new_r10*x402))+(((-1.0)*x401)));
evalcond[7]=(((new_r01*new_r12))+(((-1.0)*new_r11*x402))+x400);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x403=((((-1.0)*(1.0)*new_r02*sj3))+((cj3*new_r12)));
IkReal x404=(cj3*new_r02);
IkReal x405=(new_r12*sj3);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x403;
evalcond[7]=x403;
evalcond[8]=(x405+x404);
evalcond[9]=((((-1.0)*x404))+(((-1.0)*x405)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x406=((1.0)*new_r01);
if( IKabs(((((-1.0)*(1.0)*new_r00*sj3))+(((-1.0)*cj3*x406)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj3*new_r00))+(((-1.0)*sj3*x406)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*(1.0)*new_r00*sj3))+(((-1.0)*cj3*x406))))+IKsqr((((cj3*new_r00))+(((-1.0)*sj3*x406))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(((((-1.0)*(1.0)*new_r00*sj3))+(((-1.0)*cj3*x406))), (((cj3*new_r00))+(((-1.0)*sj3*x406))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x407=IKsin(j5);
IkReal x408=(cj3*x407);
IkReal x409=IKcos(j5);
IkReal x410=((1.0)*x409);
IkReal x411=((-1.0)*x410);
IkReal x412=((1.0)*sj3);
IkReal x413=((((-1.0)*cj3*x410))+((sj3*x407)));
evalcond[0]=(((new_r11*sj3))+x407+((cj3*new_r01)));
evalcond[1]=(((sj3*x409))+x408+new_r01);
evalcond[2]=(((new_r10*sj3))+((cj3*new_r00))+x411);
evalcond[3]=(((cj3*new_r10))+(((-1.0)*new_r00*x412))+(((-1.0)*x407)));
evalcond[4]=(((cj3*new_r11))+(((-1.0)*new_r01*x412))+x411);
evalcond[5]=(x413+new_r00);
evalcond[6]=(x413+new_r11);
evalcond[7]=((((-1.0)*x408))+(((-1.0)*x409*x412))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x414=((((-1.0)*(1.0)*new_r02*sj3))+((cj3*new_r12)));
IkReal x415=(((new_r12*sj3))+((cj3*new_r02)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x414;
evalcond[7]=x414;
evalcond[8]=x415;
evalcond[9]=x415;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
IkReal x416=((1.0)*new_r00);
if( IKabs((((cj3*new_r01))+(((-1.0)*sj3*x416)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj3*x416))+(((-1.0)*(1.0)*new_r01*sj3)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj3*new_r01))+(((-1.0)*sj3*x416))))+IKsqr(((((-1.0)*cj3*x416))+(((-1.0)*(1.0)*new_r01*sj3))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((((cj3*new_r01))+(((-1.0)*sj3*x416))), ((((-1.0)*cj3*x416))+(((-1.0)*(1.0)*new_r01*sj3))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x417=IKcos(j5);
IkReal x418=IKsin(j5);
IkReal x419=((1.0)*x418);
IkReal x420=((-1.0)*x419);
IkReal x421=(cj3*x417);
IkReal x422=((1.0)*sj3);
IkReal x423=(((sj3*x417))+(((-1.0)*cj3*x419)));
evalcond[0]=(((new_r10*sj3))+((cj3*new_r00))+x417);
evalcond[1]=(((new_r11*sj3))+x420+((cj3*new_r01)));
evalcond[2]=(x421+((sj3*x418))+new_r00);
evalcond[3]=(((cj3*new_r10))+x420+(((-1.0)*new_r00*x422)));
evalcond[4]=(((cj3*new_r11))+(((-1.0)*new_r01*x422))+(((-1.0)*x417)));
evalcond[5]=(x423+new_r01);
evalcond[6]=(x423+new_r10);
evalcond[7]=((((-1.0)*x421))+new_r11+(((-1.0)*x418*x422)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x424=((1.0)*cj4);
IkReal x425=((((-1.0)*x424))+new_r22);
IkReal x426=((1.0)*sj4);
IkReal x427=((((-1.0)*x426))+new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
evalcond[1]=x425;
evalcond[2]=x425;
evalcond[3]=x427;
evalcond[4]=new_r12;
evalcond[5]=x427;
evalcond[6]=(((new_r22*sj4))+(((-1.0)*new_r02*x424)));
evalcond[7]=((((-1.0)*new_r20*x424))+(((-1.0)*new_r00*x426)));
evalcond[8]=((((-1.0)*new_r01*x426))+(((-1.0)*new_r21*x424)));
evalcond[9]=((1.0)+(((-1.0)*new_r02*x426))+(((-1.0)*new_r22*x424)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2(new_r10, new_r11);
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x428=IKcos(j5);
IkReal x429=IKsin(j5);
IkReal x430=((1.0)*x429);
IkReal x431=((-1.0)*x430);
IkReal x432=((1.0)*new_r22);
evalcond[0]=(((new_r02*x428))+new_r20);
evalcond[1]=(new_r10+x431);
evalcond[2]=(new_r11+(((-1.0)*x428)));
evalcond[3]=(((new_r22*x429))+new_r01);
evalcond[4]=((((-1.0)*new_r02*x430))+new_r21);
evalcond[5]=(new_r00+(((-1.0)*x428*x432)));
evalcond[6]=((((-1.0)*new_r00*x432))+((new_r02*new_r20))+x428);
evalcond[7]=(((new_r02*new_r21))+(((-1.0)*new_r01*x432))+x431);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x433=((1.0)*cj4);
IkReal x434=((((-1.0)*x433))+new_r22);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
evalcond[1]=x434;
evalcond[2]=x434;
evalcond[3]=(sj4+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*(1.0)*sj4))+(((-1.0)*(1.0)*new_r02)));
evalcond[6]=(((new_r22*sj4))+((cj4*new_r02)));
evalcond[7]=(((new_r00*sj4))+(((-1.0)*new_r20*x433)));
evalcond[8]=((((-1.0)*new_r21*x433))+((new_r01*sj4)));
evalcond[9]=((1.0)+((new_r02*sj4))+(((-1.0)*new_r22*x433)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x435 = IKatan2WithCheck(IkReal(((-1.0)*(((1.0)*new_r21)))),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x435.valid){
continue;
}
CheckValue<IkReal> x436=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x436.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(x435.value)+(((1.5707963267949)*(x436.value))));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[8];
IkReal x437=IKsin(j5);
IkReal x438=IKcos(j5);
IkReal x439=((1.0)*new_r02);
IkReal x440=((-1.0)*x437);
IkReal x441=((1.0)*x438);
evalcond[0]=(((new_r02*x437))+new_r21);
evalcond[1]=((((-1.0)*x438*x439))+new_r20);
evalcond[2]=((((-1.0)*(1.0)*new_r10))+x440);
evalcond[3]=((((-1.0)*x441))+(((-1.0)*(1.0)*new_r11)));
evalcond[4]=(((new_r22*x437))+(((-1.0)*(1.0)*new_r01)));
evalcond[5]=((((-1.0)*new_r22*x441))+(((-1.0)*(1.0)*new_r00)));
evalcond[6]=((((-1.0)*new_r20*x439))+((new_r00*new_r22))+x438);
evalcond[7]=((((-1.0)*new_r21*x439))+((new_r01*new_r22))+x440);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j5]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x443=IKPowWithIntegerCheck(sj4,-1);
if(!x443.valid){
continue;
}
IkReal x442=x443.value;
CheckValue<IkReal> x444=IKPowWithIntegerCheck(cj3,-1);
if(!x444.valid){
continue;
}
CheckValue<IkReal> x445=IKPowWithIntegerCheck(cj4,-1);
if(!x445.valid){
continue;
}
if( IKabs((x442*(x444.value)*(x445.value)*(((((-1.0)*(1.0)*new_r01*sj4))+((new_r20*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x442)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x442*(x444.value)*(x445.value)*(((((-1.0)*(1.0)*new_r01*sj4))+((new_r20*sj3))))))+IKsqr(((-1.0)*new_r20*x442))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((x442*(x444.value)*(x445.value)*(((((-1.0)*(1.0)*new_r01*sj4))+((new_r20*sj3))))), ((-1.0)*new_r20*x442));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x446=IKcos(j5);
IkReal x447=IKsin(j5);
IkReal x448=((1.0)*x447);
IkReal x449=(cj3*new_r01);
IkReal x450=(new_r11*sj3);
IkReal x451=(cj4*x447);
IkReal x452=((1.0)*sj3);
IkReal x453=((-1.0)*x448);
IkReal x454=((1.0)*x446);
IkReal x455=(cj3*new_r00);
IkReal x456=(new_r10*sj3);
IkReal x457=(cj3*x454);
IkReal x458=((1.0)*cj4);
evalcond[0]=(new_r20+((sj4*x446)));
evalcond[1]=((((-1.0)*sj4*x448))+new_r21);
evalcond[2]=(x450+x451+x449);
evalcond[3]=(((cj3*new_r10))+(((-1.0)*new_r00*x452))+x453);
evalcond[4]=(((cj3*new_r11))+(((-1.0)*new_r01*x452))+(((-1.0)*x454)));
evalcond[5]=(((cj3*x451))+((sj3*x446))+new_r01);
evalcond[6]=((((-1.0)*cj4*x454))+x455+x456);
evalcond[7]=(((sj3*x447))+new_r00+(((-1.0)*cj4*x457)));
evalcond[8]=((((-1.0)*x457))+new_r11+((sj3*x451)));
evalcond[9]=((((-1.0)*cj4*x446*x452))+new_r10+(((-1.0)*cj3*x448)));
evalcond[10]=((((-1.0)*x456*x458))+((new_r20*sj4))+x446+(((-1.0)*x455*x458)));
evalcond[11]=(x453+(((-1.0)*x449*x458))+(((-1.0)*x450*x458))+((new_r21*sj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x461=IKPowWithIntegerCheck(sj4,-1);
if(!x461.valid){
continue;
}
IkReal x459=x461.value;
IkReal x460=((1.0)*new_r20);
CheckValue<IkReal> x462=IKPowWithIntegerCheck(sj3,-1);
if(!x462.valid){
continue;
}
if( IKabs((x459*(x462.value)*(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj3*cj4*x460)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*x459*x460)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x459*(x462.value)*(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj3*cj4*x460))))))+IKsqr(((-1.0)*x459*x460))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j5array[0]=IKatan2((x459*(x462.value)*(((((-1.0)*(1.0)*new_r00*sj4))+(((-1.0)*cj3*cj4*x460))))), ((-1.0)*x459*x460));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x463=IKcos(j5);
IkReal x464=IKsin(j5);
IkReal x465=((1.0)*x464);
IkReal x466=(cj3*new_r01);
IkReal x467=(new_r11*sj3);
IkReal x468=(cj4*x464);
IkReal x469=((1.0)*sj3);
IkReal x470=((-1.0)*x465);
IkReal x471=((1.0)*x463);
IkReal x472=(cj3*new_r00);
IkReal x473=(new_r10*sj3);
IkReal x474=(cj3*x471);
IkReal x475=((1.0)*cj4);
evalcond[0]=(((sj4*x463))+new_r20);
evalcond[1]=((((-1.0)*sj4*x465))+new_r21);
evalcond[2]=(x466+x467+x468);
evalcond[3]=(((cj3*new_r10))+x470+(((-1.0)*new_r00*x469)));
evalcond[4]=(((cj3*new_r11))+(((-1.0)*new_r01*x469))+(((-1.0)*x471)));
evalcond[5]=(new_r01+((cj3*x468))+((sj3*x463)));
evalcond[6]=(x472+x473+(((-1.0)*cj4*x471)));
evalcond[7]=(((sj3*x464))+(((-1.0)*cj4*x474))+new_r00);
evalcond[8]=(((sj3*x468))+new_r11+(((-1.0)*x474)));
evalcond[9]=((((-1.0)*cj4*x463*x469))+(((-1.0)*cj3*x465))+new_r10);
evalcond[10]=((((-1.0)*x473*x475))+(((-1.0)*x472*x475))+((new_r20*sj4))+x463);
evalcond[11]=((((-1.0)*x467*x475))+x470+(((-1.0)*x466*x475))+((new_r21*sj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j5array[1], cj5array[1], sj5array[1];
bool j5valid[1]={false};
_nj5 = 1;
CheckValue<IkReal> x476=IKPowWithIntegerCheck(IKsign(sj4),-1);
if(!x476.valid){
continue;
}
CheckValue<IkReal> x477 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*(((1.0)*new_r20))),IKFAST_ATAN2_MAGTHRESH);
if(!x477.valid){
continue;
}
j5array[0]=((-1.5707963267949)+(((1.5707963267949)*(x476.value)))+(x477.value));
sj5array[0]=IKsin(j5array[0]);
cj5array[0]=IKcos(j5array[0]);
if( j5array[0] > IKPI )
{
    j5array[0]-=IK2PI;
}
else if( j5array[0] < -IKPI )
{    j5array[0]+=IK2PI;
}
j5valid[0] = true;
for(int ij5 = 0; ij5 < 1; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 1; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];
{
IkReal evalcond[12];
IkReal x478=IKcos(j5);
IkReal x479=IKsin(j5);
IkReal x480=((1.0)*x479);
IkReal x481=(cj3*new_r01);
IkReal x482=(new_r11*sj3);
IkReal x483=(cj4*x479);
IkReal x484=((1.0)*sj3);
IkReal x485=((-1.0)*x480);
IkReal x486=((1.0)*x478);
IkReal x487=(cj3*new_r00);
IkReal x488=(new_r10*sj3);
IkReal x489=(cj3*x486);
IkReal x490=((1.0)*cj4);
evalcond[0]=(((sj4*x478))+new_r20);
evalcond[1]=((((-1.0)*sj4*x480))+new_r21);
evalcond[2]=(x481+x482+x483);
evalcond[3]=(((cj3*new_r10))+(((-1.0)*new_r00*x484))+x485);
evalcond[4]=(((cj3*new_r11))+(((-1.0)*new_r01*x484))+(((-1.0)*x486)));
evalcond[5]=(((sj3*x478))+((cj3*x483))+new_r01);
evalcond[6]=((((-1.0)*cj4*x486))+x488+x487);
evalcond[7]=(((sj3*x479))+new_r00+(((-1.0)*cj4*x489)));
evalcond[8]=(((sj3*x483))+(((-1.0)*x489))+new_r11);
evalcond[9]=((((-1.0)*cj3*x480))+(((-1.0)*cj4*x478*x484))+new_r10);
evalcond[10]=(x478+((new_r20*sj4))+(((-1.0)*x488*x490))+(((-1.0)*x487*x490)));
evalcond[11]=((((-1.0)*x482*x490))+(((-1.0)*x481*x490))+x485+((new_r21*sj4)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(6);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "<robot:GenericRobot - kr120_with_torch (9334c6d9b6b34813abdc6fffff1140ad)>"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
